"""Fit a spatiotemporal Kriging model to the given points containing radar- and
gauge-measured rainfall accumulations. This implementation uses methods
implemented in PyKrige (https://geostat-framework.readthedocs.io/projects/pykrige/en/stable)
so that the third dimension is reserved for time. The fitting is done to
the variable log10(gauge / radar). Additional variables may be included when
using regression-Kriging.

Input
-----
- radar-gauge pair file generated by running collect_radar_gauge_pairs.py with
  attribute "gauge_location" included. When using regression_kriging, the
  pairs are also expected to contain the "distance_to_radar" attribute.

Output
------
Pickle dump containing the fitted model.

Configuration files (in the config/<profile> directory)
-------------------------------------------------------
- fit_kriging_model.cfg
"""

import argparse
import configparser
import os
import pickle

import numpy as np
from pykrige.ok import OrdinaryKriging
from pykrige.ok3d import OrdinaryKriging3D
from pykrige.rk import RegressionKriging

try:
    from sklearn.linear_model import LinearRegression

    SKLEARN_IMPORTED = True
except ImportError:
    SKLEARN_IMPORTED = False

# parse command-line arguments
argparser = argparse.ArgumentParser()
argparser.add_argument("rgpairfile", type=str, help="radar-gauge pair file")
argparser.add_argument("outfile", type=str, help="output file")
argparser.add_argument("profile", type=str, help="configuration profile to use")
args = argparser.parse_args()

# read configuration file
config = configparser.ConfigParser()
config.read(os.path.join("config", args.profile, "fit_kriging_model.cfg"))

if config["kriging"]["method"] not in ["ordinary", "regression"]:
    raise ValueError(
        f"unsupported Kriging method {config['kriging']['method']}: choose 'ordinary' or 'regression'"
    )

radar_gauge_pairs = pickle.load(open(args.rgpairfile, "rb"))

# collect radar-gauge pairs for fitting the model
x = []
y = []
if int(config["kriging"]["dimensions"]) == 3:
    z = []
val = []

for timestamp in radar_gauge_pairs.keys():
    for fmisid in radar_gauge_pairs[timestamp].keys():
        p = radar_gauge_pairs[timestamp][fmisid]
        x_, y_ = p[2]["gauge_location"]

        x.append(x_)
        y.append(y_)
        if int(config["kriging"]["dimensions"]) == 3:
            z.append(timestamp.timestamp())
        val.append(np.log10(p[1] / p[0]))

if len(val) < int(config["kriging"]["min_valid_points"]):
    raise Exception(
        f"{len(val)} radar-gauge pairs found but {config['kriging']['min_valid_points']} required"
    )

if int(config["kriging"]["dimensions"]) == 3:
    if config["kriging"]["time_scaling_factor"] == "auto":
        # a heuristic value to relate the standard deviations of the
        # spatial coordinates and timestamps to each other
        anisotropy_scaling_z = 0.5 * (np.std(x) + np.std(y)) / np.std(z)
    else:
        anisotropy_scaling_z = float(config["kriging"]["time_scaling_factor"])

n_closest_points = int(config["kriging"]["n_closest_points"])
if n_closest_points == 0:
    n_closest_points = None

val = np.array(val)
mask = np.logical_and(
    val >= float(config["kriging"]["min_corr_factor"]),
    val <= float(config["kriging"]["max_corr_factor"]),
)

print(f"Number of valid / all radar-gauge pairs: {np.sum(mask)} / {len(x)}")

x = np.array(x)[mask]
y = np.array(y)[mask]
if int(config["kriging"]["dimensions"]) == 3:
    z = np.array(z)[mask]
val = val[mask]

if config["kriging"]["method"] == "ordinary":
    if int(config["kriging"]["dimensions"]) == 2:
        model = OrdinaryKriging(
            x,
            y,
            val,
            variogram_model="spherical",
            verbose=True,
        )
    else:
        model = OrdinaryKriging3D(
            x,
            y,
            z,
            val,
            variogram_model="spherical",
            anisotropy_scaling_z=anisotropy_scaling_z,
            verbose=True,
        )
else:
    if not SKLEARN_IMPORTED:
        raise ModuleNotFoundError(
            "sklearn needed for fitting regression models not found"
        )

    dists = []
    for timestamp in radar_gauge_pairs.keys():
        for fmisid in radar_gauge_pairs[timestamp].keys():
            dists.append(radar_gauge_pairs[timestamp][fmisid][2]["distance_to_radar"])

    dists = np.array(dists)[mask]

    regression_model = LinearRegression()

    if int(config["kriging"]["dimensions"]) == 3:
        method = "ordinary3d"
        anisotropy_scaling = (1, anisotropy_scaling_z)
    else:
        method = "ordinary"
        anisotropy_scaling = (1, 1)

    model = RegressionKriging(
        regression_model=regression_model,
        method=method,
        variogram_model="spherical",
        anisotropy_scaling=anisotropy_scaling,
        n_closest_points=n_closest_points,
        verbose=True,
    )
    points = (
        np.column_stack([x, y, z])
        if int(config["kriging"]["dimensions"]) == 3
        else np.column_stack([x, y])
    )
    model.fit(dists[:, np.newaxis], points, val)

pickle.dump(model, open(args.outfile, "wb"))
