"""Apply fitted Kriging model to calculate gridded gauge-radar correction
factors.

Input
-----
- Kriging model file generated by running fit_kriging_model.py

Output
------
The output is two arrays:
  1: gridded gauge-radar correction factors corr = log10(gauge / radar)
  2: Kriging variance of the correction factors

If regression-Kriging is used, the variance is not estimated and its set to
zero.

Two output formats are supported: GeoTIFF and compressed npz file.

Configuration files (in the config/<profile> directory)
-------------------------------------------------------
- compute_kriged_correction_factors.cfg
- radar_locations.yaml

Notes
-----
When applying this script, make sure that the target time is within the time
range used for model fitting. Kriging does not give good results when applied
to extrapolation. Also make sure that the output grid is sufficienly covered
by the gauge locations.
"""

import argparse
import configparser
from datetime import datetime
import os
import pickle

from affine import Affine
import numpy as np
import pyproj
from rasterio import features
import shapely
import yaml

import exporters
import util

# parse command-line arguments
argparser = argparse.ArgumentParser()
argparser.add_argument("model", type=str, help="Kriging model file")
argparser.add_argument("outtime", type=str, help="time stamp for output (YYYYmmddHHMM)")
argparser.add_argument("outfile", type=str, help="output file (without extension)")
argparser.add_argument("profile", type=str, help="configuration profile to use")
args = argparser.parse_args()

# read configuration file
config = configparser.ConfigParser()
config.read(
    os.path.join("config", args.profile, "compute_kriged_correction_factors.cfg")
)

if config["kriging"]["method"] not in ["ordinary", "regression"]:
    raise ValueError(
        f"unsupported Kriging method {config['kriging']['method']}: choose 'ordinary' or 'regression'"
    )

with open(os.path.join("config", args.profile, "radar_locations.yaml"), "r") as f:
    config_radarlocs = yaml.safe_load(f)
radar_locs = util.read_radar_locations(config_radarlocs)

# read Kriging model
model = pickle.load(open(args.model, "rb"))

projection = config["grid"]["projection"]

# read configuration and initialize the output grid
ll_lon = float(config["grid"]["ll_lon"])
ll_lat = float(config["grid"]["ll_lat"])
ur_lon = float(config["grid"]["ur_lon"])
ur_lat = float(config["grid"]["ur_lat"])

n_pixels_x = int(config["grid"]["n_pixels_x"])
n_pixels_y = int(config["grid"]["n_pixels_y"])

pr = pyproj.Proj(projection)
ll_x, ll_y = pr(ll_lon, ll_lat)
ur_x, ur_y = pr(ur_lon, ur_lat)

grid_x = np.linspace(ll_x, ur_x, n_pixels_x + 1)
grid_x += 0.5 * (grid_x[1] - grid_x[0])
grid_x = grid_x[:-1]

grid_y = np.linspace(ll_y, ur_y, n_pixels_y + 1)
grid_y += 0.5 * (grid_y[1] - grid_y[0])
grid_y = grid_y[:-1]

ts = datetime.strptime(args.outtime, "%Y%m%d%H%M")
grid_z = np.ones((1,)) * ts.timestamp()

# project radar locations to grid coordinates
radar_xy = {}
for radar in radar_locs.keys():
    x, y = pr(radar_locs[radar][0], radar_locs[radar][1])
    radar_xy[radar] = (x, y)

# compute gridded distances to the nearest radar for the regression model
radar_dist_grid = util.compute_gridded_distances_to_nearest_points(
    ll_x,
    ll_y,
    ur_x,
    ur_y,
    int(config["grid"]["n_pixels_x"]),
    int(config["grid"]["n_pixels_y"]),
    radar_xy,
)

if config["kriging"]["method"] == "ordinary":
    zvalues, sigmasq = model.execute("grid", grid_x, grid_y, grid_z)

    zvalues = zvalues[0, :]
    sigmasq = sigmasq[0, :]

    zvalues.set_fill_value(np.nan)
    sigmasq.set_fill_value(np.nan)

    xp = model.X_ORIG
    yp = model.Y_ORIG
else:
    p = radar_dist_grid.flatten()[:, np.newaxis]
    n_x = len(grid_x)
    n_y = len(grid_y)
    grid_x, grid_y = np.meshgrid(grid_x, grid_y)
    xp = np.column_stack(
        [grid_x.flatten(), grid_y.flatten(), grid_z[0] * np.ones(grid_x.size)]
    )
    zvalues = model.predict(p, xp).reshape((n_y, n_x))
    sigmasq = np.zeros(zvalues.shape)

    xp = model.krige.model.X_ORIG
    yp = model.krige.model.Y_ORIG

gauge_xy = {}
for i in range(len(xp)):
    gauge_xy[i] = (xp[i], yp[i])

gauge_dist_grid = util.compute_gridded_distances_to_nearest_points(
    ll_x,
    ll_y,
    ur_x,
    ur_y,
    int(config["grid"]["n_pixels_x"]),
    int(config["grid"]["n_pixels_y"]),
    gauge_xy,
)

radar_dist_mask = radar_dist_grid < float(config["output"]["max_dist_to_nearest_radar"])
gauge_dist_mask = gauge_dist_grid < float(config["output"]["max_dist_to_nearest_gauge"])

exclude_mask = radar_dist_mask

if config.getboolean("output", "gauge_convex_hull_mask"):
    geom = shapely.MultiPoint(np.column_stack([xp, yp]))
    convex_hull = shapely.convex_hull(geom)

    xscale = (ur_x - ll_x) / int(config["grid"]["n_pixels_x"])
    yscale = (ur_y - ll_y) / int(config["grid"]["n_pixels_y"])
    transform = Affine(xscale, 0, ll_x, 0, yscale, ll_y)
    convex_hull_mask = features.rasterize(
        [convex_hull],
        out_shape=zvalues.shape,
        transform=transform,
        fill=0,
        default_value=1,
    )

    exclude_mask = np.logical_and(
        exclude_mask, np.logical_or(convex_hull_mask == 1, gauge_dist_mask)
    )
else:
    exclude_mask = np.logical_and(exclude_mask, gauge_dist_mask)

if float(config["output"]["mask_blur_distance"]) > 0:
    weights = util.compute_mask_boundary_weights(
        exclude_mask, float(config["output"]["mask_blur_distance"])
    )
    zvalues *= weights
    zvalues[weights == 0] = np.nan
else:
    zvalues[~exclude_mask] = np.nan

if config["output"]["type"] == "geotiff":
    pr = pyproj.Proj(config["grid"]["projection"])

    ll_x, ll_y = pr(config["grid"]["ll_lon"], config["grid"]["ll_lat"])
    ur_x, ur_y = pr(config["grid"]["ur_lon"], config["grid"]["ur_lat"])

    bounds = [ll_x, ll_y, ur_x, ur_y]
    out_rasters = np.stack([zvalues, sigmasq])
    fn = args.outfile + ".tif"
    exporters.export_geotiff(fn, out_rasters, config["grid"]["projection"], bounds)
elif config["output"]["type"] == "numpy":
    np.savez_compressed(args.outfile, corr=zvalues.filled(), corr_var=sigmasq.filled())
else:
    raise ValueError(
        f"Output format {config['output']['type']} not supported. The valid options are 'geotiff' and 'numpy'"
    )
